## 批注的实现

### Windows和Mac传屏

```
    551                 Dango（传屏器）
  传屏显示端  ----协议A------  Mac传屏发送端
     |              ／
    广播C           ／
     |           ／
    批注    ---协议B--------  Windows传屏发送端
```

协议A：旧版本Mac与551的传屏方案
协议B：新版本由于不能与旧版本兼容，所以新开辟了一个协议。Mac和Window端都使用这个协议。
广播C：旧版本显示端在显示/切换传屏时，会有广播出来通知，当前操作是START还是EXIST。

B协议内容为：
`<prot><msg mode='1' isHandled='false' fileName='remote_92ef5c62-87eb-43d0-9305-6c409d434a68_8.jpg' size='52991' total='9' current='9' platform='1' uid='92ef5c62-87eb-43d0-9305-6c409d434a68'/></prot><prot>[data]</prot>`

其中：

* mode 表示命令
* fileName 表示传屏内容，PPT的截图，后缀`_N`表示第N页PPT内容。
* size 表示截图大小
* total 表示PPT总页数
* current 表示当前PPT展示页
* platform 表示发送端平台：1表示windows 2表示mac
* uid 表示发送端的标识
* [data] 表示如果是图片，后续就是图片的二进制流。

* Mac端是单页批注

由于Mac不能获取总页数、当前页截图等等信息，所以Mac和Windows虽然走的是同一个协议，但Mac端只是有几个命令：开始播放PPT、结束播放PPT、传屏端信息。无法拿到页码，就只能进行单页批注。

* 到这里一定有人问，为何广播C，和协议B里面都有开启／结束？

首先，广播C描述的是，传屏显示端是否在活动。而协议B里描述是，PPT是否播放中。两者不一致，比如，传屏显示中，不一定就是PPT播放中。

* Dango一旦连接，协议B就会发生通信

Dango那里，不知道当前是否在传屏显示中。即Dango连接上了，但Mac端没有点击传送，Mac端进行PPT播放，协议B就已经有数据流。
本来这里可以设计成，传送后才进行数据发送。
但Dango是否点击了传送的状态，Dango自身也不知道，所以导致无法在点击后，才进行协议B数据传输。只能是连上了就开始传输。由551批注端，根据广播C来判断，当前是否在传屏显示中，来决定是否响应协议B里面的操作。
同时，连接上就传输数据，另一点是，Mac端PPT的播放状态，由批注端自己保存了。如果点击后才进行数据通信，则Mac端PPT的播放状态，需要由Mac端保存。

* Windows传屏多页批注

Windows端连接上传屏器，如果在PPT播放中，会发送PPT的页码、总页数、PPT所有截图、传屏平台信息等等。

### 本地多页批注

本地多页批注，需要开启`AccessibilityService`，然后通过实现自己的`AccessibilityService`来获取当前窗口显示的内容，以此来跟踪本地PPT。其中：

1. ppt播放，是由`AccessibilityEvent`触发来检测的，点击播放，会产生Event，然后获取顶层窗口信息，如果发现是播放窗口，就认为是播放状态。
2. ppt翻页，是由`AccessibilityService`服务自身的接口，主动获取聚焦窗口的信息，通过信息里面的页码文本来知道当前页码和总页数。

其中第2点的先决条件是：

* View必须是可见的。由于PPT播放时，View是隐藏的，所以即使主动获取，也不会获取到窗口的信息，所以修改了系统源码，使其无论是隐藏与否，都被添加到`AccessibilityNodeInfo`中，这样主动获取就可以获取到对应的结点，从中拿到页码和总页数。
* View必须是聚焦的。就好比软键盘，显示的时候必须是Focus才能显示软键盘。同样，获取当前窗口信息，只是指获取聚焦的那个窗口的信息。所以，批注中的弹窗，都是NonFocus的，否则会抢了PPT的焦点，导致无法获取页码。

如果你发现，PPT播放时，多页批注可以显示出来，但翻页时，批注无法跟着翻页，就说明获取页码失败了。相对而言，开始播放的检测是相对稳定的。

### 书写加速

书写加速是指，通过直接写framebuffer来提高笔迹或橡皮擦的显示和处理速度。通常做法是framebuffer写的过程，应用层就记录了数据点集，抬手时应用内也开始处理这一笔。由于framebuffer和android应用层都是写的同一块fb0，当framebuffer解锁时，android应用层就会按照同一个算法，将数据集绘制出来。可以将这个过程理解成两帧，第一帧是fb来绘制，第二帧由android来绘制，由于两帧的绘制算法一致，数据集一致，所以笔迹是一样的。笔迹和橡皮擦都是在framebuffer层加速。

优点是：提高了书写速度
缺点是：冻屏与划破屏幕。所谓冻屏是指，Android和fb不能同时写，写fb时，Android层无法操作导致UI不会刷新。所谓划破屏幕是指，界面上的UI，在笔迹经过时，会对UI产生撕裂。主要是因为，写fb时，Android层无法刷新，所以被fb层划破。白板在fb层对UI区域进行了判断，所以不会划破。

#### 有鼠标层的加速

部分机型有鼠标层，比如551、510。鼠标层通常是fb1，在fb0之上。所以在fb1上进行冻屏加速，不会影响到Android层写fb0。所以可以做到，不冻屏加速。

缺点是，书写抬手后会发生笔迹变动，比如，批注写完一笔，会看到先变大后变小。这主要是因为fb0和fb1的笔迹进行了叠加，笔迹边缘的透明部分因叠加而变粗，鼠标层fb1消失后，透明区域变淡，看起来变小。

鼠标层加速的方案是，fb0为android所用，fb1为加速所用。当书写时，在fb1上写，冻fb1的屏，抬手时，fb0根据采集的数据点，绘制出fb0层的笔迹，两层笔迹重叠，fb0绘制结束，通知fb1消失。橡皮擦擦除时，fb0的笔迹会被重绘到fb1（你可以看到，橡皮差擦除时，笔迹从工具栏底下飘到了工具栏上面），然后橡皮擦擦除fb1上的笔迹，抬手时，fb0根据结果重新绘制。

#### 没有鼠标层的加速

部分机型没有鼠标层，比如3399。没有鼠标层，意味着加速只能做在fb0层，所以冻屏无法避免。
