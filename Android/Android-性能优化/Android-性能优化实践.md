## Android性能优化实践

文章参考《Android性能优化来龙去脉总结》

写得很好的一篇文章。

#### 常见性能问题

* 内存问题
	* 内存泄漏
	* 频繁GC
	* OOM
* 耗电问题

#### 内存泄漏

为什么内存泄漏会影响性能？

根据Android的垃圾清理机制，对象在Young Generation（年轻代）中存活了一段时间之后，如果没被干掉，那么会被移动到Old Generation（老年代）中，同理，最后会移动到Permanent Generation中（永久代）。

因为Android的沙盒机制，分配应用的内存有一个极限值，应用不能逾越。所以内存泄漏会导致应用可用的内存越来越少，继而影响应用的性能，最后会导致OOM。

内存泄漏也有大小。具体见另一篇《内存如何泄漏》

内存泄漏分两种情况：

* 无限内存泄漏
* 固定内存泄漏

无限内存泄漏是指，每次都会产生新的无法回收的内存垃圾。这种情况，比较容易发现，只要进行长时间测试，就会出现OOM崩溃。这种情况，影响性能比较明显，因为使用一段时间后，要么卡，要么崩。

固定内存泄漏，是指每次只会出现一份无法回收的内存垃圾。常见于那些没有管理好的变量，在退出时还持有内存引用，在再次进入时又会创建新的内存挂在这个引用上，旧的那份内存得以释放。这种情况，不会导致应用崩溃，但会影响到应用可用的内存空间。会导致频繁GC。

#### 频繁GC

频繁GC发生的情况：

* 内存泄漏，导致可用内存变小，不得不进行GC。
* 大量对象短时间被创建，又在短时间内“需要”被释放。

比如，在onDraw中new对象，因为onDraw大约16ms会执行一次（wait，你能否确定一下，什么是大约16ms，对不起，不能，掉帧了就不是，哪怕掉那么一点点）。脑补一下，每秒中创建大约60个对象，嗯，骚年，你以为Young Generation是白菜么，想拿多少就拿多少，对不起，这里是限量的，这里用完了，在来申请，我就得去回收一些回来，我回收总得耗时间吧，好吧，耗时间，onDraw 等着等着就错过了下一个16ms的执行了，如是，用户看起来就卡了。

#### OOM

导致OOM的情况：

* 内存泄漏，导致可用内存变小，新的对象已经无法创建。
* 没有内存泄漏，但真的没有内存可用了，GC也回收不了内存。

情况1，需要修复内存泄漏。
情况2，可以压缩内存，优化内存占用，及时释放内存，减少全局对象等等。具体可见：

1、优化数据结构，减少内存占用。

比如，`List<Bitmap>`和`List<String>`的方式，元素是Bitmap远比元素是路径要占用更多内存。

2、优化列表数量，合理设置接口的列表数据集合。

比如，请求接口返回了列表有100项数据，每项数据比如有100个字段，其中你用户展示数据的只有10几个而已，但是，你解析的时候，剩下的99个不知不觉吃了你的内存，当，有个胖子要内存时，呵呵，嗝屁了。

3、压缩图片。

比如，每个图只需要加载一个`100*100`的，你却使用原始尺寸（`1080*1980`）or更大，而且你一下子还加载个几十张，扛得住么？所以了解一下inSampleSize，或者，如果图片归你们上传管理，你可以借助万象优图，他为你做了剪切好不同尺寸的图片，这样省得你在客户端做图片缩放了。

比如，减少解码图片的运算，提高性能。一些图片格式`jpg/png/webp`解码的性能各不相同。webp解码稍微比png优。

关于图片的分析，这里有一篇《移动端图片格式调研》<https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/>

4、及时释放内存。

比如，一个流程结束，就可以立即结束这个流程的内存占用。比如，对象已经不需要再使用了，但还挂在当前Service中。

5、使用磁盘缓存。

比如，要上传一系列图片，如果使用`List<Bitmap>`的方式，分分钟让你OOM。所以可以先缓存到磁盘，然后逐一上传。
可以适当的将大对象缓存到磁盘。

6、借助数据库。

数据库也是磁盘缓存，但速度应该比普通的磁盘访问要快。

写着写着，大概已经有人发现，说好的性能优化，上面的一些举措，明明会降低应用的性能，反而让应用更慢（比如，磁盘缓存）。

是的。性能和空间，永远是两个相互制衡的因素。内存空间大，可以牺牲空间换取性能。但OOM的情况是，不得已的时候，只能牺牲性能，换取空间。

这里的性能优化，体现在，不合理的使用内存，会导致内存爆满，性能下降，甚至OOM；同样，不正确的内存优化，会导致内存利用率不高，降低了应用的性能。

#### 内存问题

内存泄漏、频繁GC、OOM可以归纳为内存问题。内存会影响到性能，主要是影响了新对象的创建。表现在：
1. GC，因为GC也是需要时间的，而且影响广泛。
2. 因为要GC，所以新对象的创建速度变慢了，整个程序就会变慢。

#### 耗电问题

a、没有什么特别重要的信息，比如，钱到账，电话来了，100元实打实无门槛代金券方法，等等，请不要打扰用户，不要频繁唤醒用户，否则，结果只能是卸载，或者关闭一切通知。

b、适当的做本地缓存，避免频繁请求网络数据，这里，说起来容易，做起来并非三刀两斧就能搞定，要配合良好的缓存策略，区分哪些是一段时间不会变更的，哪些是绝对不能缓存的很重要。

c、对某些执行时间较长的同步操作在用户充电且有wifi的时候在做，除非用户强制同步..等等，就不扯太多，因为后面还有很多内容。

归结为：

* 通知耗电
* 唤醒耗电
* 网络通信耗电（4G比wifi耗电）
* 执行时间长的操作耗电
* CPU运算高的耗电
* 音视频播放耗电（软解码比硬解码耗电）
